# Advent of Code 2025

- https://adventofcode.com/
- https://github.com/livexia/advent-of-code-2025

## Day 1

今天的问题算是轻松，输入的每一行决定旋钮的转向和旋转的距离，输入的处理也不复杂，但是要注意在解析数字时的错误处理，输入处理完成后，如果旋钮是向左旋转则距离为负数，向右则为正数。

第一部分只需要计算旋转之后的刻度位置是否为 0 即可，可以简单的求 100 的余数即可。

第二部分稍微复杂一些，需要计算每次旋转过程中经过了多少次 0 刻度位置，给出的测试用例较小，实际的输入旋转的距离可能是多圈的，要考虑到这一点。首先计算每一次旋转的距离至少有多少圈，每转一圈密码加一。接着计算整圈之外的旋转距离，如果起始点不在 0 ，那么旋转结束后，如果刻度跨过 0 刻度，密码加一。因为向左旋转距离是负数，如果当前位置不为 0 ，同时当前位置加上旋转距离为负数，则旋钮指针一定向左跨过一次 0 。同理如果当前位置不为 0 （不为 100），同时向右旋转，而旋转后的刻度数超过 100 ，那么指针一定向右旋转过一次 0。根据这个逻辑对 password 进行加一即可。

第二部分代码

```rust
fn part2(rotations: &[i32]) -> Result<u32> {
    let _start = Instant::now();

    let mut dial = 50;
    let mut password = 0;

    for rot in rotations {
        // 计算一定会经过 0 刻度的整圈次数
        password += rot.unsigned_abs() / 100;

        // 扣除整圈的旋转距离，
        // 可以规避例如从 0 刻度旋转距离 100 的边界情况
        let rot = rot % 100;

        let temp = dial + rot;
        // 当起点不是 0 刻度时，
        // 向左或向右旋转超过或位于刻度边界 0 或 100 时，
        // 一定经过一次 0 刻度
        password += (dial != 0 && (temp >= 100 || temp <= 0)) as u32;

        // 计算旋转后刻度的真实位置，刻度值一定大于 0
        dial = temp.rem_euclid(100);
    }

    println!("part2: {password}");
    println!("> Time elapsed is: {:?}", _start.elapsed());
    Ok(password)
}
```

## Day 2

今天要求找出区间内存在重复模式的数字，第一部分要求找出左右两个部分相同的数字，第二部分要求找出数字经过 N 等分后，每个部分都相同的数字。第二部分其实是第一部分的衍生，解题思路在两个部分是一致的。我首先利用暴力法得出题解，通过取余的方法不断的分割数字，对比分割的结果，即可确定是否存在重复模式。暴力法效率不高，因为我遍历了区间内的所有数字，依次检查数字，这样实际效率很慢。

### 渐进寻找

暴力法中区间内的数字是依次递增的，但是应该有更加高效的方法确定符合重复模式的数字。考虑区间 565653-565659 ，可见这个区间中所有的数字都是 6 位等长的，我们先考虑第一部分的重复模式，即数字的前半部分和后半部分应当相同。考虑区间起点 565653 ，直接将区间按照重复模式进行分割，可得到两个数字 565 和 653 ，同样的将结尾也进行分割得到 565 和 659 ，可见两个数字的前半部分相同，那么这个部分就不能变动，那么 653 和 659 就应该变化为 565 ，得到的数字是 565565 不在区间内。所以按照第一部分的匹配模式，无法从区间内寻找到符合的数字。那么考虑第二部分的匹配模式，这个区间的数字长度都为 6 ，那么存在长度为 1、2 和 3 的三种分割模式。确定区间起点和结尾数字中，共同的部分为 56565，那么根据这个共同部分进行分割，可以发现长度 1 或 3 的分割模式是不可能的。考虑分割长度为 2 ，那么分割后每个部分都需要是 56 才行，同时 56 刚好落入起点和结尾 53 - 59 之间，那么长度为 2 的分割可行。

这个方法存在一种情况，那就是如果区间的数字长度不一致，比如区间 95-115 就不容易寻找了，当然可以把区间进行拆分，95-115 变成 95-99 和 100-115 两个区间，分开寻找即可。

**效率对比**

```
part1: 26255179562
> Time elapsed is: 22.953333ms
part2: 31680313976
> Time elapsed is: 37.9495ms
part1 by step: 26255179562
> Time elapsed is: 58.208µs
part2 by step: 31680313976
> Time elapsed is: 70.834µs
```

渐进查找主要代码
```rust
fn split_range(start: usize, end: usize) -> Vec<(usize, usize)> {
    let (start_l, end_l) = (start.ilog10(), end.ilog10());
    if start_l < end_l {
        let mut ranges = vec![];
        let mut start = start;
        for i in start_l..=end_l {
            let new_end = 10usize.pow(i + 1) - 1;
            ranges.push((start, new_end.min(end)));
            start = new_end + 1;
        }
        ranges
    } else {
        vec![(start, end)]
    }
}

fn find_invalid(start: usize, end: usize, base: u32) -> Vec<usize> {
    assert_eq!(start.ilog10(), end.ilog10());
    let l = start.ilog10() + 1;
    if !l.is_multiple_of(base) {
        return vec![];
    }
    let (start_left, end_left) = (start / 10usize.pow(l - base), end / 10usize.pow(l - base));
    let mut invalids = Vec::new();
    for s in start_left..=end_left {
        let n = (0..l)
            .step_by(base as usize)
            .fold(0, |n, i| n + s * 10usize.pow(i));
        if start <= n && n <= end {
            invalids.push(n);
        }
    }
    invalids
}
```

## Day 3

今天要求计算一个数字序列的最大子串（数字），第一部分限定子串长度为2，第二部分则限定长度为12，同时子串的顺序不变。输入的处理不复杂，思路也很简单，就是遍历数字序列，依次寻找最大值即可。

考虑数字序列 96781 ，需要寻找长度为 2 的最大子串，假设子串为 ab ，那么优先从给定序列中确定最大的 a ，同时确保能找到 b 即可。搜索 a 时从左到右进行搜索，而搜索到最后一个数字之前就需要停止，也就是搜索 9678 即可。在搜索 a 的过程中不必考虑是否可能会导致 b 的值不是最大，因为最后的要求的是 ab 最大即可。假设搜索过程中为了确保 b 的值为最大的 d ，而导致 a 取得了较小的值 c，即 c < a 且 d > b ，那么 10 * c + d 一定小于 10 * a + b 。

两个部分对于子串的长度要求不同，但是思路是一致的。从左到右依次搜索字串最大值的过程中，需要记录第一次遇到最大值的元素位置，而非其他可能遇到最大值的位置，这样可以避免影响后续元素最大值搜索。参考序列 98975，需要寻找长度为 2 的最大子串，a 确定搜索到的最大值为 9，如果 a 记录的最大值位置不为 0 而为 2 ，那么搜索 b 时就会从位置 3 开始搜索，最后得到子串为 97 ，是错误结果。

贪心算法核心代码

```rust
fn find_largest_joltage(battery: &[usize], number: usize) -> usize {
    let length = battery.len();
    let mut joltage = 0;
    let mut next_battery = 0;
    for l in (0..number).rev() {
        let mut max_battery = 0;
        (next_battery..(length - l)).for_each(|left| {
            if battery[left] > max_battery {
                max_battery = battery[left];
                next_battery = left + 1;
            }
        });
        joltage = joltage * 10 + max_battery;
    }
    joltage
}
```

这个算法还可以进行剪枝，因为输入的数字序列限制，实际上如果搜索到最大数字为 9 就不需要继续搜索了，这可以进行一定的剪枝，但是我的实现用了 for_each 就具体实现了。

看到一个基本思路一致，但是实现上不同的方法 [ropewalker](https://www.reddit.com/r/adventofcode/comments/1pcvaj4/comment/ns0smcw) [code](https://github.com/ropewalker/advent_of_code_2025/blob/master/src/day03.rs) ，通过滑动限定长度窗口，依次取得最大值，实现不同但算法是一样的，效率应该也没有差别。

目前我的实现在查找过程中实际上存在大量的浪费，因为必须要比较到最后才能确定最大值，而每次查找最大值时都进行了一次。社区上也有人使用 DP 进行优化这个过程，即在一次比较中不断记录当前位置到末尾处的最大值，具体我就不实现了，做一下分析。

阅读社区上他人的动态规划代码 [michel-kraemer](https://github.com/michel-kraemer/adventofcode-rust/blob/main/2025/day03/src/main.rs)，这个实现使用的是自底向上的动态规划，过程中数组 dp 记录的是，长度为 len 的子串从 i 开始的最大子串，转移方程是 dp[len][i] = max(number[i]*mul + dp[len - 1][i + 1])，dp 从长度 1 以及从数字序列最后开始计算。

参考核心代码

```rust
fn dp_find_largest_joltage(battery: &[usize], number: usize) -> usize {
    let length = battery.len();
    let mut dp = vec![vec![0; length + 1]; number + 1];
    let mut mul = 1;
    for len in 1..=number {
        let mut max = 0;
        for (i, &b) in battery.iter().enumerate().take(length - len + 1).rev() {
            max = max.max(b * mul + dp[len - 1][i + 1]);
            dp[len][i] = max;
        }
        mul *= 10;
    }
    dp[number][0]
}
```

理论上 dp 应该要能减少比较的次数，但是这个实现实际的运行效率远不如我的暴力法，对比核心代码实际可以发现比较的次数并没有减少，虽然运行时都是 O(Nk)，N是序列长度，k是子串长度，但是增加了数组操作，整体反而增加了计算成本。比较次数没有减少，是因为每次计算 dp 时，依旧需要从初始位置开始比对到当前的结尾位置，冗余的比较依旧存在。

动态规划算法的核心

- dp[len][i]=从 battery[i..] 中选择 len 个数字，保持相对顺序串联得到的最大值。
- 边界条件（已初始化）：dp[0][i]=0：从任何位置开始选择 0 个数字，结果都是 0。
- 外部循环：按长度 (len) 迭代 `for len in 1..=number` 这个循环是按构建数字的位数从小到大进行计算。DP 算法的关键是利用小规模子问题的解来推导大规模问题的解。在这里，要计算 dp[len][i]，我们必须先知道 dp[len−1][j] 的值。
- 内部循环：按起始索引 (i) 迭代 `for (i, &b) in battery.iter().enumerate().take(length - len + 1).rev()`
- 优化原理：当我们在计算 dp[len][i] 时，我们在考虑从 battery[i..] 中选择 len 个数字。有两种情况：
    - 选择 battery[i] 作为第一个数字： 得到的数字是 battery[i]⋅mul+dp[len−1][i+1]。
    - 不选择 battery[i] 作为第一个数字： 这意味着第一个数字是从 battery[i+1..] 中选的，所以这等价于 dp[len][i+1]。

当前解决的这个特定问题，贪心算法在运行效率（常数时间和空间）上是更优的选择。但在算法设计的普适性上，DP 算法则更为强大。

## Day 04

今天的问题简洁明了，输入是二维的矩阵，其中每个位置上可能存在一卷纸，如果一个卷纸的八个邻接位置上只有小于三个位置上是卷纸时，叉车可以将卷纸移除。第一部分是移除一次，第二部分则是反复进行操作，直到矩阵中所有的卷纸都无法再被移除。问题的核心就是计算矩阵中每个卷纸邻接卷纸的个数，然后根据需求修改矩阵状态。

最直接的思路就是利用二位数组，直接将输入的字符串，转为二维字符数组，接着遍历每一个位置，计算八个邻接位置，判断其中是卷纸的数量。第二部分则需要多次遍历，每次遍历中需要记录移除的卷纸坐标，当一次遍历完成后，根据记录的坐标修改矩阵，将卷纸移除。思路简单明了，也得到了正确的答案，但是我对运行效率不满意，第一部分运行时间是 22ms ，而第二部分则是 273 ms。

第一部分的时间复杂度是 O(N) 其中 N 是矩阵大小，而第二部分的时间复杂度是 O(kN) 其中 k 时可能需要的遍历移除次数，k 最大为最初的卷纸数量。

二维数组模拟输入，实际上非常直观，但是数组存在使用上的局限性，比如八个邻接位置的判断，需要考虑边界条件。同时在这个问题中，第二部分需要搜索的矩阵大小实际上应该是逐渐减小的，而用数组表示则无法利用这个优势。用 HashSet 表示在实现上更加方便，集合只记录所有卷纸的坐标，搜索邻接八个位置时，只需要判断位置是否位于集合中，不必额外考虑坐标边界情况。虽然在实现上更加简便，但是效率却变差了，虽然时间复杂度没有变化，但是 HashSet 的操作更加耗时，最后两部分的运行时间分别是 45ms 和 1s。即便是优化了部分 HashSet 方法的使用，最后的运行时间依旧比不上数组，两部分分别只能做到 48ms 和 437 ms。从第一部分的运行时间差距可以发现，实际上 HashSet 的效率是远比不上数组访问。

### 初步优化（第二部分）

第一部分实际上没有什么优化空间，在这个问题中 Vec 的效率远比 Hash 效率高，优化的主要集中在第二部分。第二部分中移除是分批实现的，即先判断所有的卷纸是否能被移除，然后一次性移除，接着再次判断和移除。这样的实现可以确保结果正确性，但是能否判断一个就移除一个呢？因为所有的卷纸只可能会被移除，不会有新的卷纸产生，如果一个卷纸目前有四个邻接的卷纸，而其中一个卷纸被移除了，那么不需要等到下一次判断，这次就可以一并移除，虽然也会有漏网之鱼，但也能较大的提高运行效率。

实现这个优化采用二维矩阵比 HashSet 更加方便，因为在 Rust 中一边遍历 HashSet 一边又要删除元素是无法实现的（safe），一般来说也不推荐这样做，因为修改遍历对象属于遍历副作用，可能会导致循环无法结束。

在利用 Vec 实现这个优化之后，运行时间并没有大幅下降，第二部分运行时间是 173 ms，差不多少了 100ms。

### 进一步优化

运行效率不高的原因是，在每一个卷纸位置上进行搜索时，需要对领接的八个位置都进行判断，而这个过程又需要反复进行。如果能将搜索邻接位置的结果进行缓存，或者不需要每次都进行判断应该就能大幅降低运行时间。

考虑使用 HashMap 表示输入，其键为卷纸坐标，值为邻接的八个位置中有几个是卷纸。需要提前从输入构筑，初始的邻接搜索必须要进行。每一次搜索时，遇到一个卷纸位置，如果当前卷纸可以被移除，那么邻接八个位置在 HashMap 中的值就需要减 1 。

实际上也可以使用 Vec 二维数组实现，考虑 HashMap 可能存在操作的开销。但是这个思路可以进一步延伸，在搜索一个位置时，如果能提前判断邻接的八个位置是否能被移除，那就可以提前的确定这个卷纸是否能被移除。当然要规避如果 A 移除了，邻接的 B 就能被移除，同时如果 B 被移除，A 也就能被移除，这样的互相限制。

这样的优化终归是局部性的，并不是一劳永逸的，同时是有些盲目的操作。进一步我又想到，实现这个优化最好的数据结构是优先队列，键依旧是坐标，值依旧是邻接的卷纸数量。这个思路看似不错，但是并不容易，因为我需要快速的查找最小值，同时又要求 O(1) 的根据键并修改优先级。可以使用 HashMap + BinaryHeap 实现，HashMap 实时记录位置处邻接卷纸的数量，BinaryHeap 是最小堆，如果堆顶的值大于 4 则说明所有能被移除的卷纸已经被全部移除了。代码具体实现可见 [code](https://github.com/livexia/advent-of-code-2025/commit/3ada45bc2ee0c1cb4a47232aae5d158a766f7660#diff-9babad5b20f1c504f9c4b1d031fd57e6f1a1198343b707f377d777b64c50f47b)，第二部分的运行时间下降到 70ms。

### 使用 BFS 实现

前面的优化实际上就是更加复杂的 BFS ，但是我是在阅读了社区的题解之后才意识到可以使用 BFS 实现。

BFS 也需要用到两个数据结构，VecDeque 和 HashMap ，其中队列中保存的是当前矩阵中邻接卷纸数量小于 4 的卷纸坐标，而 HashMap 则不断记录着每个卷纸的邻接卷纸数量。

每次从队列中弹出卷纸时，更新这个卷纸的邻接卷纸的邻接数量，如果数量小于 4 则将该邻接卷纸入队，依次进行直到队列为空。具体实现见代码 [code](https://github.com/livexia/advent-of-code-2025/blob/main/aoc04/src/main.rs)，第二部分运行时间差不多是 70ms ，这个 BFS 实际上和前面的优化是一致的，所以在时间上没有快很多，但是算法更加简洁实现也更加容易。

因为暴力的方法很简单，所以没有单列与代码中，因为很久没写代码了，所以对于 BFS 有所模糊，最终的代码之保留了 BFS 的实现，BFS 中使用到的 Hash 数据结构也可以通过 Vec 替代，因为输入较小这样也可以提高实际的运行效率，同时提及的运行时间都是 debug 下得到的，release 的运行时间会更少。
